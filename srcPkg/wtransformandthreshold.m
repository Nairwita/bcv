function significants = ...
    wtransformandthreshold(data, startTime, tiling, ...
               outlierFactor, falseEventRate, ...
               analysisMode, channelNames, coefficients, coordinate, ...
               referenceTime, timeRange, frequencyRange, qRange, ...
               maximumSignificants, falseVetoRate, ...
               uncertaintyFactor, correlationFactor, ...
               debugLevel)
% WTRANSFORMANDTHRESHOLD transform data and identify significant tiles
%
% WTRANSFORMANDTHRESHOLD applies the discrete Q transform described by the
% predetermined tiling structure to frequency domain data from multiple
% detectors, potentially after transformation into a new basis of virtual data
% streams for coherent analysis.  It then identifies the coefficients whose
% magnitudes exceed the threshold that approximately yields the specified single
% channel false rate assuming ideal white noise.
%
% The tiling structure contains the transform parameters and is generated by the
% WTILE function.  The input data should be the fourier transform of the time
% series data to be analyzed.  However, the input frequency series should only
% extend from zero frequency to the Nyquist frequency.  As a result, the input
% frequency series should be of length N / 2 + 1, where N is the length of the
% original input time series.
%
% usage: significants = ...
%    wtransformandthreshold(data, startTime, tiling, ...
%               outlierFactor, falseEventRate, ...
%               analysisMode, channelNames, coefficients, coordinate, ...
%               referenceTime, timeRange, frequencyRange, qRange, ...
%               maximumSignificants, falseVetoRate, ...
%               uncertaintyFactor, correlationFactor, ...
%               debugLevel)
%
% The following input variables are required:
%
%   data                 cell array of input frequency series data
%   startTime            GPS start time of Q transformed data
%   tiling               discrete Q tranform tiling structure from WTILE
%   outlierFactor        Tukey whisker multiplier for outlier rejection
%   falseEventRate       desired white noise false event rate [Hz]
%
% following not required:
%
%   analysisMode         what type of analysis to do ('independent')
%   channelNames         cell array of single detector channel names
%   coefficients         cell array of filter coefficients from WCONDITION
%   coordinate           sky position
%   referenceTime        reference time for time range to threshold on
%   timeRange            vector range of relative times to threshold on
%   frequencyRange       vector range of frequencies to threshold on
%   qRange               scalar Q or vector range of Qs to threshold on
%   maximumSignificants  maximum allowable number of significant tiles
%   falseVetoRate        desired white noise veto rate [Hz]
%   uncertaintyFactor    squared calibration uncertainty factor
%   correlationFactor    fractional correlated energy threshold
%   debugLevel           verboseness of debug output
%
% output:
%
%   significants         cell array of Q transform event structures
%
% The sky position should be specified as a two component vector of
% the form [theta phi] as used by WTILESKY and WSKYMAP.  The
% coordinate theta is a geocentric colatitude running from 0 at the
% North pole to pi at the South pole, and the coordinate phi is the
% geocentric longitude in Earth fixed coordinates with 0 on the prime
% meridian.  The units are radian, the range of theta is [0, pi] and
% the range of phi is [0, 2 pi).
%
% WTRANSFORMANDTHRESHOLD returns a cell array of Q transform event structures
% that contain the properties of the identified statistically significant tiles
% for each channel.  The event structure contains the following fields.
%
%   time                 center time of tile [gps seconds]
%   frequency            center frequency of tile [Hz]
%   q                    quality factor of tile []
%   duration             duration of tile [seconds]
%   bandwidth            bandwidth of tile [Hz]
%   normalizedEnergy     normalized energy of tile []
%   amplitude            signal amplitude of tile [Hz^-1/2]
%   overflowFlag         boolean overflow flag
%   channelName          name of channel
%
% For coherent transform data, the following field is also returned.
%
%   incoherentEnergy     incoherent energy of tile []
%
% The user can focus on a subset of the times and frequencies available in
% the transform data by specifying a desired range of central times,
% central frequencies, and Qs to threshold on.  Ranges should be specified
% as a two component vector, consisting of a minimum and maximum value.
% Alternatively, if only a single Q is specified, WTHRESHOLD is only
% applied to the time-frequency plane which has the nearest value of Q in a
% logarithmic sense to the requested value.
%
% To determine the range of central times to threshold on, WTHRESHOLD
% requires the start time of the transformed data in addition to a
% reference time and a relative time range.  Both the start time and
% reference time should be specified as absolute quantities, while the
% range of times to analyze should be specified relative to the requested
% reference time.
%
% By default, WTHRESHOLD is applied to all available frequencies and Qs,
% and the reference time and relative time range arguments are set to
% exclude data potentially corrupted by filter transients as identified by
% the transient duration field of the tiling structure.  The default value
% can be obtained for any argument by passing the empty matrix [].
%
% The threshold is set to yield the specified false event rate when applied
% to all available frequencies and Qs, and is not modified to account for
% restricted ranges.  It is also only a rough estimate, and the result
% false event rate may vary significantly depending on the quality of the
% data.
%
% If provided, the optional analysisMode string is used by WTHRESHOLD to
% determine which channels are signal channels, which channels are null
% channels, and which channels to report results for.  For coherent analysis
% modes, a desired white noise veto rate, squared calibration uncertainy
% factor, and required signal correlation factor must also be specified.
%
% The optional maximumSignificants argument provides a safety mechanism to
% limit the total number of events returned by WTHRESHOLD.  If this maximum
% number of significants is exceeded, the overflow flag is set, only the
% maximumSignificants most significant tiles are returned, and a warning is
% issued if debugLevel is set to 1 or higher.  By default, maximumSignificants
% is set to infinity and debugLevel is set to unity.
%
% See also WTILE, WCONDITION, and WSELECT.

% ***** See documentation for QH1H2.
% ***** This requires modifying WEVENTGRAM to also display incoherent energies.

% Shourov K. Chatterji <shourov@ligo.mit.edu>
% Antony C. Searle <acsearle@ligo.caltech.edu>
% Jameson Rollins <jrollins@phys.columbia.edu>

% $Id: wtransform.m 1715 2009-04-10 16:19:58Z jrollins $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                  process/validate command line arguments                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% verify correct number of input arguments
error(nargchk(5, 18, nargin));

% infer analysis type from missing arguments and
% construct default arguments
if (nargin < 6) || isempty(analysisMode),
  analysisMode = 'independent';
end
if (nargin < 7),
  channelNames = [];
end
if (nargin < 8) || isempty(coefficients),
  if ~any(strcmpi(analysisMode, {'independent'})),
    error('further inputs required for coherent analysis modes')
  end
  coefficients = [];
end
if (nargin < 9) || isempty(coordinate),
  coordinate = [pi/2,0];
end
if (nargin < 10) || isempty(referenceTime),
  referenceTime = startTime + tiling.duration / 2;
end
if (nargin < 11) || isempty(timeRange),
  timeRange = 0.5 * (tiling.duration - 2 * tiling.transientDuration) * [-1 +1];
end
if (nargin < 12) || isempty(frequencyRange),
  frequencyRange = [-Inf +Inf];
end
if (nargin < 13) || isempty(qRange),
  qRange = [-Inf +Inf];
end
if (nargin < 14) || isempty(maximumSignificants),
  maximumSignificants = Inf;
end
if (nargin < 15) || isempty(falseVetoRate),
  falseVetoRate = 0;
end
if (nargin < 16) || isempty(uncertaintyFactor),
  uncertaintyFactor = 0;
end
if (nargin < 17) || isempty(correlationFactor),
  correlationFactor = 0;
end
if (nargin < 18) || isempty(debugLevel),
  debugLevel = 1;
end

% validate tiling structure
if ~strcmp(tiling.id, 'Discrete Q-transform tile structure'),
  error('input argument is not a discrete Q transform tiling structure');
end

if ~any(strcmpi(analysisMode, {'independent', 'coherent', 'bayesian'})),
  error('unknown analysis mode "%s"\n', analysisMode)
end

% force cell arrays
data = wmat2cell(data);
channelNames = wmat2cell(channelNames, ~isempty(channelNames));
coefficients = wmat2cell(coefficients, ~isempty(coefficients));

% force one dimensional cell arrays
data = data(:);
channelNames = channelNames(:);
coefficients = coefficients(:);

% determine number of channels
numberOfChannels = length(data);

% check channel names exist
if isempty(channelNames)
  if strcmp(analysisMode,'independent')
    % provide default channel names
    channelNames = cell(numberOfChannels, 1);
    for channelNumber = 1:numberOfChannels,
      channelNames{channelNumber} = ['X' int2str(channelNumber)];
    end
  else
    % must supply channel names for coherent analyses that need them for
    % antenna patterns
    error('must provide channelNames for coherent analysis');
  end
end

% check coefficients exist
if isempty(coefficients)
  if strcmp(analysisMode,'independent')
    % provide default coefficients
    coefficients = cell(numberOfChannels, 1);
    for channelNumber = 1:numberOfChannels,
      coefficients{channelNumber} = ones(size(data{channelNumber}));
    end
  else
    % must supply coefficients for coherent analyses that need them for
    % response matrix
    error('must provide coefficients for coherent analysis');
  end
end

% determine required data lengths
dataLength = tiling.sampleFrequency * tiling.duration;
halfDataLength = dataLength / 2 + 1;

% validate data length and force row vectors
for channelNumber = 1 : numberOfChannels,
  data{channelNumber} = data{channelNumber}(:).';
  if length(data{channelNumber}) ~= halfDataLength,
    error('data length not consistent with tiling');
  end
end

% validate number of coefficients vectors
if length(coefficients) ~= numberOfChannels,
    error('coefficients are inconsistent with number of channels');
end

% validate coefficients length and force row vectors
for channelNumber = 1 : numberOfChannels,
    coefficients{channelNumber} = coefficients{channelNumber}(:).';
    if length(coefficients{channelNumber}) ~= halfDataLength,
        error('coefficients length not consistent with tiling');
    end
end

% determine number of sites
sites = unique(regexprep(channelNames, '.:.*$', ''));
numberOfSites = length(sites);

% validate channel names
if ~isempty(channelNames) && (length(channelNames) ~= numberOfChannels),
    error('channel names are inconsistent with number of transform channels');
end

% ensure collocated network if it was implied by omitting coordinate
if nargin == 5 && numberOfSites ~= 1
    error('coordinate must be provided for non-collocated networks');
end

if strcmp(analysisMode, 'coherent'),
  if numberOfChannels < 2,
    error('not enough channels for a coherent analysis (>2 required)');
  end
end
    
% force coordinate row vector
coordinate = coordinate(:).';

% validate coordinate vector
if length(coordinate) ~= 2,
    error('coordinates must be a two component vector [theta phi]');
end

% extract spherical coordinates                  % ***** currently unused *****
theta = coordinate(:, 1);                        % ***** currently unused *****
phi = coordinate(:, 2);                          % ***** currently unused *****

% validate spherical coordinates                 % ***** currently unused *****
if (theta < 0) || (theta > pi),                  % ***** currently unused *****
    error('theta outside of range [0, pi]');     % ***** currently unused *****
end                                              % ***** currently unused *****
if (phi < 0) || (phi >= 2 * pi),                 % ***** currently unused *****
    error('phi outside of range [0, 2 pi)');     % ***** currently unused *****
end                                              % ***** currently unused *****

% force ranges to be monotonically increasing column vectors
timeRange = unique(timeRange(:));
frequencyRange = unique(frequencyRange(:));
qRange = unique(qRange(:));

% if only a single Q is requested, find nearest Q plane
if length(qRange) == 1,
  [ignore, qPlane] = min(abs(log(tiling.qs / qRange)));
  qRange = tiling.qs(qPlane) * [1 1];
end

% Check for two component range vectors
if length(timeRange) ~= 2,
  error('Time range must be two component vector [tmin tmax].');
end
if length(frequencyRange) ~= 2,
  error('Frequency range must be two component vector [fmin fmax].');
end
if length(qRange) > 2,
  error('Q range must be scalar or two component vector [Qmin Qmax].');
end



%%%%%%%%%%%%%%%%%%%%%%%%%%% FROM WTRANSFORM %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         setup analysis modes                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
switch lower(analysisMode)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                  setup independent/bayesion analysis                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 case {'independent','bayesian'}

  intermediateData = data;
  numberOfIntermediateChannels = numberOfChannels;
  numberOfOutputChannels = numberOfChannels;
  outputChannelNames = channelNames;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        setup coherent analysis                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 case {'coherent'}

  % determine detector antenna functions and time delays
  [fplus, fcross, deltat] = wresponse(coordinate, channelNames);

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                    time shift detector data                         %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % use first-listed detector as time reference (this has the advantage of
  % making collocated work naturally)
  deltat = deltat - deltat(1);

  % frequency vector
  frequency = 0 : (1/tiling.duration) : tiling.sampleFrequency / 2;

  % time shift data by frequency domain phase shift
  for channelNumber = 1 : numberOfChannels,
    data{channelNumber} = data{channelNumber} .* ...
                          exp(sqrt(-1) * 2 * pi * frequency * ...
                              deltat(channelNumber));
  end

  % clear unecessary frequency vector
  clear frequency;

  % concatenated list of detector identifiers
  detectors = [];
  for channelNumber = 1 : numberOfChannels,
    detectors = [detectors channelNames{channelNumber}(1:2)];
  end
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                     construct new basis                             %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % form the response matrix
  responseMatrix = [fplus; fcross]';

  % Simple basis (not taking into account power spectrum) is useful tool to
  % understand structure of the SVD
  %
  % [u,s,v] = svd(responseMatrix);
  %
  % If s(2,2) does not exist or is zero we are insensitive to the 
  % second polarization and we can compute only the primary signal component 
  % and N - 1 null streams
  %
  % If s(2,2) exists and is nonzero, we can compute the primary 
  % and secondary signal components and N - 2 null streams

  % preallocate the coefficient structure
  basis = cell(numberOfChannels);
  for i = 1:numberOfChannels
    for j = 1:numberOfChannels
      basis{i,j} = zeros(size(coefficients{1}));
    end
  end

  % preallocate the responseMatrix for a given frequency
  f = zeros(size(responseMatrix));

  %for each frequency bin
  for frequencyNumber = 1:halfDataLength,
      % for each channel form the response matrix including the noise
      % coefficients
      for channelNumber = 1:numberOfChannels,
        f(channelNumber,:) = responseMatrix(channelNumber,:) .* ...
            coefficients{channelNumber}(frequencyNumber);
      end
      % compute the singular value decomposition
      [u, s, v] = svd(f);

      % repack the orthonormal basis coefficients into the output 
      % structure
      for i = 1:numberOfChannels
        for j = 1:numberOfChannels
          basis{i,j}(frequencyNumber) = u(i,j);
        end
      end
  end
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                          setup coherent outputs                     %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  intermediateData = cell(numberOfChannels);
  for i = 1:numberOfChannels,
    for j = 1:numberOfChannels
      intermediateData{i,j} = basis{i,j} .* data{i};
    end
  end
    
  % free the memory associated with the input data
  clear data;
    
  %setup output metadata
  numberOfIntermediateChannels = numberOfChannels^2;

  numberOfOutputChannels = 2;
  outputChannelNames{1} = [detectors ':SIGNAL-COHERENT'];
  outputChannelNames{2} = [detectors ':SIGNAL-INCOHERENT'];
    
  % output null stream if network allows
  if (numberOfSites >= 3) || (numberOfChannels > numberOfSites),
    numberOfOutputChannels = 4;
    outputChannelNames{3} = [detectors ':NULL-COHERENT'];
    outputChannelNames{4} = [detectors ':NULL-INCOHERENT'];
  end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              otherwise error                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 otherwise

  error(['unknown analysis mode: ' analysisMode]);
   
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                          end setup analysis modes                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      initialize Q transform structures                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% create empty cell array of Q transform structures
transforms = cell([1,numberOfOutputChannels]);

% begin loop over channels
for outputChannelNumber = 1 : numberOfOutputChannels,

  % insert structure identification string
  transforms{outputChannelNumber}.id = 'Discrete Q-transform transform structure';

  % create empty cell array of Q plane structures
  transforms{outputChannelNumber}.planes = cell(size(tiling.planes));

  % begin loop over Q planes
  for plane = 1 : tiling.numberOfPlanes,

    % create empty cell array of frequency row structures
    transforms{outputChannelNumber}.planes{plane}.rows = ...
        cell(size(tiling.planes{plane}.numberOfRows));

  % end loop over Q planes
  end

% end loop over channels
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FROM WTHRESHOLD %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         normalized energy threshold                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% approximate number of statistically independent tiles per second
independentsRate = tiling.numberOfIndependents / tiling.duration;

% apply emperically determined correction factor
independentsRate = independentsRate * 1.5;

% probability associated with desired false event rate
falseEventProbability = falseEventRate / independentsRate;

% probability associated with desired false veto rate
falseVetoProbability = falseVetoRate / independentsRate;

% normalized energy threshold for desired false event rate
eventThreshold = -log(falseEventProbability);

% normalized energy threshold for desired false veto rate
if falseVetoProbability == 0,
  vetoThreshold = Inf;
else
  vetoThreshold = -log(falseVetoProbability);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                             apply analysis mode                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% switch on analysis mode
switch lower(analysisMode),

  case {'independent', 'bayesian'},

    % threshold on all signal channels individually
    for channelNumber = 1 : numberOfChannels,
      outputChannels{channelNumber}.channelName = channelNames{channelNumber};
      outputChannels{channelNumber}.channelType = 'signal';
      outputChannels{channelNumber}.signalChannel = channelNumber;
      outputChannels{channelNumber}.referenceChannel = [];
    end

  case {'coherent'},

    % threshold on signal channel
    outputChannels{1}.channelName = regexprep(outputChannelNames{1}, '-.*$', '');
    outputChannels{1}.channelType = 'signal';
    outputChannels{1}.signalChannel = 1;
    outputChannels{1}.referenceChannel = 2;

    % threshold on null channel
    if numberOfChannels > 2,
      outputChannels{2}.channelName = regexprep(outputChannelNames{3}, '-.*$', '');
      outputChannels{2}.channelType = 'null';
      outputChannels{2}.signalChannel = 3;
      outputChannels{2}.referenceChannel = 4;
    end

  otherwise,
    error(['unknown analysis mode "' analysisMode '"']);

% end switch on analysis mode
end

% number of output channels
numberOfOutputChannels = length(outputChannels);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             initialize statistically significant event structure             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% create empty cell array of significant event structures
significants = cell(numberOfOutputChannels, 1);

% create empty cell array of output channel names
channelNames = cell(numberOfOutputChannels, 1);

% begin loop over channels
for outputChannelNumber = 1 : numberOfOutputChannels

  % insert structure identification string
  significants{outputChannelNumber}.id = 'Discrete Q-transform event structure';

  % initialize result vectors
  significants{outputChannelNumber}.time = [];
  significants{outputChannelNumber}.frequency = [];
  significants{outputChannelNumber}.q = [];
  significants{outputChannelNumber}.duration = [];
  significants{outputChannelNumber}.bandwidth = [];
  significants{outputChannelNumber}.normalizedEnergy = [];
  significants{outputChannelNumber}.amplitude = [];

  % initialize overflow flag
  significants{outputChannelNumber}.overflowFlag = 0;

  % include incoherent energy for coherent channels
  if ~isempty(outputChannels{outputChannelNumber}.referenceChannel),
    significants{outputChannelNumber}.incoherentEnergy = [];
  end

  % fill cell array of output channel names
  channelNames{outputChannelNumber} = ...
      outputChannels{outputChannelNumber}.channelName;

% end loop over channels
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SHARED LOOP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           begin loop over Q planes                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% begin loop over Q planes
for plane = 1 : tiling.numberOfPlanes,

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                      begin loop over frequency rows                        %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % begin loop over frequency rows
  for row = 1 : tiling.planes{plane}.numberOfRows,

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %               extract and window frequency domain data                   %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % number of zeros to pad at negative frequencies
    leftZeroPadLength = (tiling.planes{plane}.rows{row}.zeroPadLength - 1) / 2;

    % number of zeros to pad at positive frequencies
    rightZeroPadLength = (tiling.planes{plane}.rows{row}.zeroPadLength + 1) / 2;

    % begin loop over channels
    for intermediateChannelNumber = 1 : numberOfIntermediateChannels,

      % extract and window in-band data
      windowedData{intermediateChannelNumber} = ...
          tiling.planes{plane}.rows{row}.window .* ...
          intermediateData{intermediateChannelNumber}(tiling.planes{plane}.rows{row}.dataIndices);

      % zero pad windowed data
      windowedData{intermediateChannelNumber} = ...
          [zeros(1, leftZeroPadLength) ...
           windowedData{intermediateChannelNumber} ...
           zeros(1, rightZeroPadLength)];

      % reorder indices for fast fourier transform
      windowedData{intermediateChannelNumber} = ...
          windowedData{intermediateChannelNumber}([(end / 2 : end) (1 : end / 2 - 1)]);

    % end loop over channels
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %               inverse fourier transform windowed data                    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % begin loop over channels
    for intermediateChannelNumber = 1 : numberOfIntermediateChannels,

      % complex valued tile coefficients
      tileCoefficients{intermediateChannelNumber} = ...
          ifft(windowedData{intermediateChannelNumber});

    % end loop over channels
    end 

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %              energies directly or indirectly                   %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    switch lower(analysisMode)
      case {'independent','bayesian'}

        % compute energies directly from intermediate data
        for channelNumber = 1:numberOfIntermediateChannels
          energies{channelNumber} = ...
              real(tileCoefficients{channelNumber}).^2 + ...
              imag(tileCoefficients{channelNumber}).^2 ;
        end

      case {'coherent'}
      
        % compute coherent and incoherent energies indirectly from
        % intermediate data
        for outerChannelNumber = 1:numberOfChannels
          % coherent stream energy    
          accumulatedTileCoefficients = zeros(size(tileCoefficients{1}));    
          for channelNumber = 1:numberOfChannels,
            accumulatedTileCoefficients = ...
                accumulatedTileCoefficients + ...
                tileCoefficients{channelNumber + ...
                                (outerChannelNumber - 1) * numberOfChannels};
          end
          energies{1 + (outerChannelNumber - 1) * 2} = ...
              real(accumulatedTileCoefficients).^2 + ...
              imag(accumulatedTileCoefficients).^2;

          % incoherent stream energy
          energies{2 + (outerChannelNumber - 1) * 2} = zeros(size(energies{1}));
          for channelNumber = 1:numberOfChannels,
            energies{2 + (outerChannelNumber - 1) * 2} = ...
                energies{2 + (outerChannelNumber - 1) * 2}...
                + real(tileCoefficients{channelNumber + ...
                                (outerChannelNumber - 1) * numberOfChannels}).^2 ...
                + imag(tileCoefficients{channelNumber + ...
                                (outerChannelNumber - 1) * numberOfChannels}).^2;
          end
        end
      
        % accumulate in corresponding channels
        if numberOfSites > 1
          % the second group of channels is the unwanted secondary signal
          % energy, so zero it out
          energies{3} = zeros(size(energies{3}));
          energies{4} = zeros(size(energies{4}));
        end
      
        % sum all the null energies into a single channel
        for channelNumber = 3:numberOfChannels
          energies{3} = energies{3} + energies{1 + (channelNumber - 1) * 2};
          energies{4} = energies{4} + energies{2 + (channelNumber - 1) * 2};
        end
      
    end
          
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %        exclude outliers and filter transients from statistics            %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % compute the times vector, formerly stored in ...rows{row}.times
    times = (0 :  tiling.planes{plane}.rows{row}.numberOfTiles - 1) * ...
            tiling.planes{plane}.rows{row}.timeStep;

    % begin loop over channels
    for outputChannelNumber = 1 : numberOfOutputChannels,

      % indices of non-transient tiles
      validIndices{outputChannelNumber} = ...
          find((times > ...
                tiling.transientDuration) & ...
               (times < ...
                tiling.duration - tiling.transientDuration));

      % identify lower and upper quartile energies
      sortedEnergies = ...
          sort(energies{outputChannelNumber}(validIndices{outputChannelNumber}));
      lowerQuartile{outputChannelNumber} = ...
          sortedEnergies(round(0.25 * length(validIndices{outputChannelNumber})));
      upperQuartile{outputChannelNumber} = ...
          sortedEnergies(round(0.75 * length(validIndices{outputChannelNumber})));

      % determine inter quartile range
      interQuartileRange{outputChannelNumber} = ...
          upperQuartile{outputChannelNumber} - ...
          lowerQuartile{outputChannelNumber};

      % energy threshold of outliers
      outlierThreshold{outputChannelNumber} = ...
          upperQuartile{outputChannelNumber} + ...
          outlierFactor * interQuartileRange{outputChannelNumber};

      % indices of non-outlier and non-transient tiles
      validIndices{outputChannelNumber} = ...
          find((energies{outputChannelNumber} < ...
                outlierThreshold{outputChannelNumber}) & ...
               (times > ...
                tiling.transientDuration) & ...
               (times < ...
                tiling.duration - tiling.transientDuration));

    % end loop over channels
    end

    % for reasonable outlier factors,
    if outlierFactor < 100,

      % mean energy correction factor for outlier rejection bias
      meanCorrectionFactor = (4 * 3^outlierFactor - 1) / ...
                             ((4 * 3^outlierFactor - 1) - ...
                             (outlierFactor * log(3) + log(4)));

    % otherwise, for large outlier factors
    else

      % mean energy correction factor for outlier rejection bias
      meanCorrectionFactor = 1;

    % continue
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %          determine tile statistics and normalized energies               %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % begin loop over channels
    for outputChannelNumber = 1 : numberOfOutputChannels,

      % mean of valid tile energies
      meanEnergy{outputChannelNumber} = ...
          mean(energies{outputChannelNumber}(validIndices{outputChannelNumber}));

      % correct for bias due to outlier rejection
      meanEnergy{outputChannelNumber} = meanEnergy{outputChannelNumber} * ...
          meanCorrectionFactor;

      % normalized tile energies
      normalizedEnergies{outputChannelNumber} = ...
          energies{outputChannelNumber} / ...
          meanEnergy{outputChannelNumber};

    % end loop over channels
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %               insert results into transform structure                    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % begin loop over channels
    for outputChannelNumber = 1 : numberOfOutputChannels,
              
      % insert mean tile energy into frequency row structure
      %transforms{outputChannelNumber}.planes{plane}.rows{row}.meanEnergy = ...
      %    meanEnergy{outputChannelNumber};

      % insert normalized tile energies into frequency row structure
      %transforms{outputChannelNumber}.planes{plane}.rows{row}.normalizedEnergies = ...
      %    normalizedEnergies{outputChannelNumber};
      
      
      
      %%%%%%%%%%%%%%%%%%%%%% INSERTED WTHRESHOLD HERE %%%%%%%%%%%%%%%%%%%%%%%%%%
      
      
      
      % skip Q planes outside of requested Q range
      if ((tiling.planes{plane}.q < min(qRange)) || ...
          (tiling.planes{plane}.q > max(qRange))),
        continue;
      end
      
      % skip frequency rows outside of requested frequency range
      if ((tiling.planes{plane}.rows{row}.frequency < ...
           min(frequencyRange)) || ...
          (tiling.planes{plane}.rows{row}.frequency > ...
           max(frequencyRange))),
          continue;
      end
     
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      %                  extract output channel details                        %
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      % extract output channel structure
      outputChannel = outputChannels{outputChannelNumber};

      % extract output channel details
      channelName = outputChannel.channelName;
      channelType = outputChannel.channelType;
      signalChannel = outputChannel.signalChannel;
      referenceChannel = outputChannel.referenceChannel;   
      
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      %                    threshold on significance                           %
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      % switch on channel type
      switch channelType,
        
        % if signal channel,
        case 'signal',

          % threshold on signal significance
          if isempty(referenceChannel),
            significantTileIndices = find( ...
                normalizedEnergies{signalChannel} >=  ...
                eventThreshold);
          else
            significantTileIndices = find( ...
                normalizedEnergies{signalChannel} >= ...
                eventThreshold + correlationFactor * ...
                normalizedEnergies{referenceChannel});
          end

        % if null channel,
        case 'null',

          % threshold on null significance
          significantTileIndices = find( ...
              normalizedEnergies{signalChannel} >= ...
              vetoThreshold + uncertaintyFactor * ...
              normalizedEnergies{referenceChannel});

      % end test for channel type
      end   
      
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      %                    threshold on central time                           %
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      % skip tiles outside requested time range
      keepIndices = ...
          (times(significantTileIndices) >= ...
           (referenceTime - startTime + min(timeRange))) & ...
          (times(significantTileIndices) <= ...
           (referenceTime - startTime + max(timeRange)));
      significantTileIndices = significantTileIndices(keepIndices);

      % number of statistically significant tiles in frequency row
      numberOfSignificants = length(significantTileIndices);     
      
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      %      append significant tile properties to event structure             %
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      % append center times of significant tiles in row
      significants{outputChannelNumber}.time = ...
          [significants{outputChannelNumber}.time ...
           times(significantTileIndices) + ...
           startTime];

      % append center frequencies of significant tiles in row
      significants{outputChannelNumber}.frequency = ...
          [significants{outputChannelNumber}.frequency ...
           tiling.planes{plane}.rows{row}.frequency * ...
           ones(1, numberOfSignificants)];

      % append qs of significant tiles in row
      significants{outputChannelNumber}.q = ...
          [significants{outputChannelNumber}.q ...
           tiling.planes{plane}.q * ...
           ones(1, numberOfSignificants)];

      % append durations of significant tiles in row
      significants{outputChannelNumber}.duration = ...
          [significants{outputChannelNumber}.duration ...
           tiling.planes{plane}.rows{row}.duration * ...
           ones(1, numberOfSignificants)];

      % append bandwidths of significant tiles in row
      significants{outputChannelNumber}.bandwidth = ...
          [significants{outputChannelNumber}.bandwidth ...
           tiling.planes{plane}.rows{row}.bandwidth * ...
           ones(1, numberOfSignificants)];
        
      % append normalized energies of significant tiles in row
      significants{outputChannelNumber}.normalizedEnergy = ...
          [significants{outputChannelNumber}.normalizedEnergy ...
           (normalizedEnergies{outputChannelNumber}(significantTileIndices))];

      % append amplitudes of significant tiles in row
      significants{outputChannelNumber}.amplitude = ...
          [significants{outputChannelNumber}.amplitude ...
           sqrt((normalizedEnergies{outputChannelNumber}(significantTileIndices) - 1) * ...
                meanEnergy{signalChannel})];

      % append incoherent energies of significant tiles in row
      if ~isempty(referenceChannel),
        significants{outputChannelNumber}.incoherentEnergy = ...
            [significants{outputChannelNumber}.incoherentEnergy ...
             (normalizedEnergies{outputChannelNumber}(significantTileIndices))];
      end
      
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      %             prune excessive significants as we accumulate              %
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      
      % determine number of significant tiles in channel
      numberOfSignificants = length(significants{outputChannelNumber}.time);

      % if maximum allowable number of significant tiles is exceeded
      if numberOfSignificants > maximumSignificants,

        % issue warning
        wlog(debugLevel, 2, '%s: trimming excess significants to maximum (%s).\n', ...
             outputChannels{outputChannelNumber}.channelName,maximumSignificants);

        % set overflow flag
        significants{outputChannelNumber}.overflowFlag = 1;

        % sort significant tiles by normalized energy
        [ignore, maximumIndices] = ...
            sort(significants{outputChannelNumber}.normalizedEnergy);

        % find indices of most significant tiles
        maximumIndices = maximumIndices(end - maximumSignificants + 1 : end);

        % extract most significant tile properties
        significants{outputChannelNumber} = ...
            wcopyevents(significants{outputChannelNumber}, maximumIndices);

      % otherwise continue
      end           

    % end loop over channels
    end

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                       end loop over frequency rows                         %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % end loop over frequency rows
  end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            end loop over Q planes                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% end loop over Q planes
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                    return discrete Q transform structure                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for channelNumber = 1 : numberOfOutputChannels,
    significants{channelNumber}.channelName = ...
        outputChannelNames{channelNumber};
end    

% return to calling function
return
