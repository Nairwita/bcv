function [event, pixelEnergy] = ...
        wcoherentanalysis(wSw, event, data, coefficients, energyTypes, ...
                          pixel, cluster, debugLevel)
% WCOHERENTANALYSIS Calculate various likelihood ratios for an event, given a 
% sky direction and a event time.
%
% WCOHERENTANALYSIS first converts frquency domain double whitened data into 
% a time series of single whitened data. The dimensions of the q-pixel holding 
% the event are used to determine a Fourier transform length to apply to the 
% time domain data so that the time-frequency pixels have the same dimension. 
% The frequency of the event is then used to retrieve the complex value of that 
% pixel. These are used to compute the requested set of likelihood ratios or
% statistics for the time-frequency pixel at the given sky position.  
%
% usage: wcoherentanalysis(wSw, event, data, coefficients, 
%                        energyTypes, pixel, cluster)
%
%   pixel               Structure containing data about the event
%                        pixel.q          - q value of event
%                        pixel.frequency  - centre frequency of event
%                        pixel.time       - centre time of event
%                        pixel.duration   - duration of event
%   cluster             Structure holding info about the cluster and data
%                         cluster.blockStartTime   - block start time
%                         cluster.theta            - sky position
%                         cluster.phi              - sky position
%                         cluster.sampleFrequency  - sample frequency of data
%                         cluster.blockDuration    - duration of block
%                         cluster.candidateChannel - cluster channel
%                         cluster.channelNames     - cell array of channel names
%   wSw                 Vector, corresponds to ~ 1/PSD for each channel.
%   event               Cell array of significant event properties
%                         time      - center time [gps seconds]
%                         frequency - center frequency [Hz]
%                         duration  - duration [seconds]
%                         bandwidth - bandwidth [Hz]
%   data                Cell array of conditioned output frequency series
%   coefficients        Cell array of frequency domain filter coefficients
%   energyTypes         Cell array of energies to calculate, can be 'cross',
%                         'plus,'null' and 'standard'
%
% The event structure is returned with the following fields appended
% to it:
%     
%   (energyType)CoherentEnergy    Scalar, value of coherent combination  
%   (energyType)IncoherentEnergy  Scalar, value of incoherent combination
%
% Where (energyType) is each of the energy types passed in 
% (e.g. crossCoherentEnergy, crossIncoherentEnergy, nullCoherentEnergy etc)
% and it returns the energy summed over all pixels of the cluster
%
% Also returned is pixelEnergy, which is used to store the energies for each
% pixel
% 
% See also WEVENT, WTRANSFORM and WMARGINALIZETRIGGER.
% NEED TO UPDATE THIS INFORMATION

% Mark Edwards <Mark.Edwards@astro.cf.ac.uk>

% $Id:$
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      Process input arguments                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% apply default arguments
if (nargin < 8) || isempty(debugLevel)
  debugLevel = 1;
end

% start time of analysis
analysisTimer = clock;

% verify correct number of input arguments
%error(nargchk(8, 9, nargin));

% If the number of arguments is 9, then no energy types have been passed in, so
% assign default values for them
%if (nargin == 8) || isempty(energyTypes)
%	energyTypes={'cross','plus', 'null', 'standard'};
%end

% determine number of channels
numberOfChannels = length(cluster.channelNames);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               Antenna response                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Calculate the antenna reponses and timeshifts relating to the sky position
% generated by the Bayesian code.

skyPosition = [cluster.theta, cluster.phi];
[Fp, Fc, deltaT] = wresponse(skyPosition, cluster.channelNames);

% Generate the whitened antenna response for each detector.  
% Note that wSw ~ 1/PSD.
wFp = Fp .* (wSw').^0.5;
wFc = Fc .* (wSw').^0.5;

% Convert to the DPF
[wFpDPF, wFcDPF, psiDPF] = converttodpf(wFp,wFc);

% Convert noise free antenna response to DPF and normalise
[FpDPF, FcDPF, psiDPF] = converttodpf(Fp,Fc);
FpDPF = FpDPF./norm(wFpDPF);
FcDPF = FcDPF./norm(wFcDPF);

% Calculate the othornormal basis vectors
ep=wFpDPF./norm(wFpDPF);
ec=wFcDPF./norm(wFcDPF);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      Manipulate frequency domain data                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Generate the single whitened data we need using the rawdata that has 
% been double whitened by the conditioning code, by dividing by the 
% coeffients. This data is in the frequency domain.

% ---- Note: dividing by coeff does not correctly handle HPF - ignore for
% now.
for channelNumber = 1:numberOfChannels;
  swData{channelNumber} = data{channelNumber}./coefficients{channelNumber};
end

% Some of the coefficients are zero, thus causing NaNs to appear in the swData
% data. To combat this, we'll find zeros in the coefficients, and set the 
% appropriate index in swData to zero
for channelNumber = 1:numberOfChannels;
  swData{channelNumber}(find(coefficients{channelNumber} == 0)) = 0;
end

% Now, reconstruct the data so that it contains the negative frequencies
% above the Nyquist data using the fact that X(k)=conj(X)(N-k) then IFFT
% back into the time domain

for channelNumber = 1:numberOfChannels;
  swData{channelNumber} = [swData{channelNumber} ...
      fliplr(conj(swData{channelNumber}(2:(end-1))))];
  swData{channelNumber} = real(ifft(swData{channelNumber}));

  
  % Keep data double whitened so that we can test the new code
  data{channelNumber} = [data{channelNumber} ...
      fliplr(conj(data{channelNumber}(2:(end-1))))];
  data{channelNumber} = real(ifft(data{channelNumber}));

end

%clear data, coefficients;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      Variable setting, including loops                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clusterPixelNumber = 1;

N = length(swData{cluster.candidateChannel});

%for channelNumber = 1:numberOfChannels

% Need to pull out the data associated with the event - thus we need the
% frequency at which it occured and the sample rate.

% Get frequency from trigger array
%eventFrequency = event.frequency;

%Get frequency from posterior array
eventFrequency = pixel.frequency;
sampleFrequency = cluster.sampleFrequency;
nyquistFrequency = sampleFrequency/2;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                       Manipulate time domain data                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Calculate values required when working in the time domain.
% Get the sample number that corresponds to the event time, and the
% number of samples we need to FFT to get the appropriate time-frequency
% pixel dimensions

[tfmap, timeSlice, frequencySlice, dirtySamples]=...
    tfmapping(swData, pixel.time-cluster.blockStartTime, pixel.frequency, ...
    pixel.duration, cluster.blockDuration, sampleFrequency, ...
    numberOfChannels, deltaT, cluster.candidateChannel);

  
% Carry this out again with the double whitened data:
[DWtfmap, DWtimeSlice, DWfrequencySlice, DWdirtySamples]=...
    tfmapping(data, pixel.time-cluster.blockStartTime, pixel.frequency, ...
    pixel.duration, cluster.blockDuration, sampleFrequency, ...
    numberOfChannels, deltaT, cluster.candidateChannel);
  
  
% Retrieve the data associated with the time of the event for each detector
% Remember the data has already been shifted to align the event in the detector.
  
for channelNumber = 1:numberOfChannels
  % Pull back the energy for that time-frequency pixel.
  energy(channelNumber) = ... 
          real(tfmap{channelNumber}(frequencySlice, timeSlice))^2 + ...
          imag(tfmap{channelNumber}(frequencySlice, timeSlice))^2;
         
  % Pull back the complex value for that time-frequency pixel.
  d(channelNumber) = tfmap{channelNumber}(frequencySlice,timeSlice);

  % Pull back the DW energy for that time-frequency pixel.
  DWenergy(channelNumber) = ... 
          real(DWtfmap{channelNumber}(DWfrequencySlice, DWtimeSlice))^2 + ...
          imag(DWtfmap{channelNumber}(DWfrequencySlice, DWtimeSlice))^2;
         
  % Pull back the complex value for that time-frequency DWpixel.
  DWd(channelNumber) = DWtfmap{channelNumber}(DWfrequencySlice,DWtimeSlice);

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                       Calculate the requested energies                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Calculate the energies requested and append the results onto the trigger
% structure

for energyNumber=1:length(energyTypes)
    switch energyTypes{energyNumber}
	case 'cross'
        % Energy in the cross polarization in the DP frame:    
        % ---- Ec = |ec.d|^2;
        % Incoherent component of the energy:
        % ---- Ic = Sum from N=1, # detectors of |ec(N).d(N)|^2

        % Pass in the cross component of the orthonormal basis vectors to 
        % calculate the energy in that polarization
        [coherentEnergy,incoherentEnergy] = ...
                      singlepolarization( ec, d);

	case 'plus'
        % Energy in the plus polarization in the DP frame.
        % Also known as the hard constraint likelihood.
        % ---- Ep = |ep.d|^2;

        % Incoherent component of the energy:
        % ---- Ip = Sum from N=1, # detectors of |ep(N).d(N)|^2

        % Pass in the plus component of the orthonormal basis vectors to 
        % calculate the energy in that polarization
        [coherentEnergy,incoherentEnergy] = ... = ...
               singlepolarization( ep, d);
        
	case 'null'
        % Null energy statistic.
        % For an general non-aligned network we have 
        % null energy = total - standard, 
        % so compute total and standard separately and take the difference.
        
    		% ---- Compute total energy.
        Etotal = d*d';
        
        % ---- Compute standard likelihoods 

          % ---- Calculate energy in the cross/plus polarizations.    
          % ---- Ec = |ec.d|^2, Ep = |ep.d|^2;
          [Ep,Ip] = singlepolarization(ep, d);
          [Ec,Ic] = singlepolarization(ec, d);
          
        % Coherent - (Ep + Ec)
        Esl = Ec + Ep;
                
        % Incoherent - (Ip + Ic)
        Isl = Ic + Ip;
        
        % ---- Subtract standard likelihood energy from the total energy 
        % to get the null energy.
        coherentEnergy   = Etotal - Esl;
        incoherentEnergy = Etotal - Isl;  
        
    case 'standard'
      % The standard likelihood can calculated as the sum of the energy in each
      % polarization.
      
      % Compute coherent/incoherent energies in each polarization
      [Ep,Ip] = singlepolarization( ep, d);
      [Ec,Ic] = singlepolarization( ec, d);

      % Sum the polarization energies
      coherentEnergy   = Ec + Ep;
      incoherentEnergy = Ic + Ip;              
               
    case 'test'
        % Compute all of the energies and sum them to check that they
        % have been calculated properly
        % If they have, we should get:
        %  Ip+Ic+In = Ep+Ec+En=Et and
        %   (Ep-Ip)+(Ec-Ic)+(En-In)=0
                
    		% ---- Compute total energy.
        totalEnergy = d*d';
        
        % ---- Compute standard likelihoods 
          % ---- Calculate energy in the cross/plus polarizations.    
          % ---- Ec = |ec.d|^2, Ep = |ep.d|^2;
          [Ep, Ip] = singlepolarization(ep, d);
          [Ec, Ic] = singlepolarization(ec, d);
          
        % Coherent - (Ep + Ec)
        Esl = Ec + Ep;
        
        % Incoherent - (Ip + Ic)
        Isl = Ic + Ip;
        
        % ---- Subtract standard likelihood energy from the total energy 
        % to get the null energy.
        % Enull = totalEnergy - Esl;
        % Inull = totalEnergy - Isl;
        
        % Create null vector
        enull = cross(ep,ec);
        % Project data onto null vector
        [Enull,Inull] = singlepolarization(enull, d);
        
        
        Etotal = Ep+Ec+Enull;
        Itotal = Ip+Ic+Inull;   
        
        if (((Etotal - totalEnergy) < eps) && ((Itotal - Etotal) < eps))
            wlog(debugLevel, 1,'Energies correctly calculated\n');
            allPass=1;
        else
            wlog(debugLevel, 1,'Energies incorrectly calculated\n');
            allPass=0;
        end
        
        ZeroPointEnergy = (Ep-Ip)+(Ec-Ic)+(Enull-Inull);
        
        if ((ZeroPointEnergy < eps) && (allPass==1))
            wlog(debugLevel, 1,'ZeroPoint correct\n');
            ratioResult = 'pass';
        else
            wlog(debugLevel, 1,'ZeroPoint incorrect\n');
            ratioResult = 'fail';
        end
        
  % Double whitened portion of test:
        
  case 'DWcross'
  % Energy in the cross polarization in the DP frame:    
  % ---- Ec = |ec.d|^2;
  % Incoherent component of the energy:
  % ---- Ic = Sum from N=1, # detectors of |ec(N).d(N)|^2

  % Pass in the cross component of the orthonormal basis vectors to 
  % calculate the energy in that polarization
  [coherentEnergy,incoherentEnergy] = ...
                singlepolarization( FcDPF, DWd);

	case 'DWplus'
        % Energy in the plus polarization in the DP frame.
        % Also known as the hard constraint likelihood.
        % ---- Ep = |ep.d|^2;

        % Incoherent component of the energy:
        % ---- Ip = Sum from N=1, # detectors of |ep(N).d(N)|^2

        % Pass in the plus component of the orthonormal basis vectors to 
        % calculate the energy in that polarization
        [coherentEnergy,incoherentEnergy] = ... = ...
               singlepolarization( FpDPF, DWd);    
             
	case 'DWnull'
        % Null energy statistic.
        % For an general non-aligned network we have 
        % null energy = total - standard, 
        % so compute total and standard separately and take the difference.
        
    		% ---- Compute total energy.
        Etotal = DWd*DWd';
        
        % ---- Compute standard likelihoods 

          % ---- Calculate energy in the cross/plus polarizations.    
          % ---- Ec = |ec.d|^2, Ep = |ep.d|^2;
         [Ep,Ip] = singlepolarization(FpDPF, DWd);
         [Ec,Ic] = singlepolarization(FcDPF, DWd);
          
        % Coherent - (Ep + Ec)
        Esl = Ec + Ep;
                
        % Incoherent - (Ip + Ic)
        Isl = Ic + Ip;
        
        % ---- Subtract standard likelihood energy from the total energy 
        % to get the null energy.
        coherentEnergy   = Etotal - Esl;
        incoherentEnergy = Etotal - Isl;  
                  
      otherwise
          error('No algorithm for computing likelihood ');
  end

% Store the cumulative energy in the event structure
event.([energyTypes{energyNumber} 'Energy']) = ...
  event.([energyTypes{energyNumber} 'Energy']) + coherentEnergy;
event.([energyTypes{energyNumber} 'IncoherentEnergy']) = ...
  event.([energyTypes{energyNumber} 'IncoherentEnergy']) + incoherentEnergy;

% Store the energy of each pixel in a seperate structure
pixelEnergy.([energyTypes{energyNumber} 'Energy']) = coherentEnergy;
pixelEnergy.([energyTypes{energyNumber} 'IncoherentEnergy']) = incoherentEnergy;

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                    return                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% return to calling function
return;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Helper functions - calculating statistics                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [E,I] = singlepolarization (e,d)

% The calculation for the plus and cross polarizations are the same, so this
% function can be passed ec or ep and calculate the appropriate coherent and
% incoherent energies.

% Coherent component - cross-correlation terms of the energy in the polarization
% of the DP frame.

% E = abs(e * d.')^2; 
	E = abs(sum(e .* d))^2;

% Incoherent energy component - autocorrelation terms of the energy in the 
% polarization in the DP frame.

  I = sum(abs(e .* d).^2);
	  
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Helper functions - calculating tfmap reshape parameters        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [tfmap, timeSlice, frequencySlice, dirtySamples]=...
  tfmapping(data, eventTime, eventFrequency, eventDuration,  ...
      dataLength, sampleFrequency, numberOfChannels, deltaT, ...
      candidateChannel)

% Function to shift and transform the data into the appropriately sized time-
% frequency map, and calculate the position of the event in the map. 
    
% Give the first detector zero time shift
deltaT = deltaT - deltaT(candidateChannel);

% Shift data for other detectors so that the event time lines up with the time
% in the first detector - keep record of dirty samples too
dirtySamples{candidateChannel} = 0;
for channelNumber = 1:numberOfChannels
  dataShift = deltaT(channelNumber)*sampleFrequency;
  data{channelNumber} = circshift(data{channelNumber},[1,-floor(dataShift)]);
  if (-floor(dataShift) < 0)
    dirtySamples{channelNumber} = ...
      [(length(data{channelNumber})-floor(dataShift)):length(data{channelNumber})];
  else
    dirtySamples{channelNumber}= ...
      [1:abs(floor(dataShift))];
  end 
end

% Determine centre of time bins 
timeResolution = 1/sampleFrequency;
binCenterTime = [timeResolution:timeResolution:dataLength].';

% Retrieve index of time bin closest to our event time
[remainderTime, eventSampleTime] = min(abs(eventTime - binCenterTime));

% Number of samples to event ***WRONG***
%eventSampleTime = round(eventTime*sampleFrequency);

% Get time duration of event in samples - force to be a power of 2 by rounding
% the log2 value up towards the nearest integer and raising 2 to this number
eventDurationSamples = 2^ceil(log2(eventDuration*sampleFrequency));
%eventDurationSamples = ceil(eventDuration*sampleFrequency);

% Need to add time shift to guarantee that event is centered in one time bin.
% So take the time of the event and center it in eventDurationSamples.
% Note that the endEventTime is actually the start time of the next
% block (take the points from startEventTime to endEventTime-1)
startEventTime = eventSampleTime - (eventDurationSamples/2);
endEventTime   = eventSampleTime + (eventDurationSamples/2);

% Need to check how many samples to ignore at the start of the time series
% so that the transform works on a multiple number of eventDurationSampless
% Need to subtract one to ensure that it just reports the number rejected
rejectedStart = mod (startEventTime-1, eventDurationSamples);

% Rejection at other end - add one to include the endEventTime sample
rejectedEnd = mod(length(data{1})-endEventTime + 1, eventDurationSamples);

if (remainderTime > eps)
	% If there is 'left over' time, shift the data
  % real(ifft(fbob.*exp((-2*pi*i/2000)*[0:1999]*200)))
end

% Loop over each detector to generate the tfmaps for each, using the dimensions
% calculated above.

for channelNumber = numberOfChannels:-1:1
  % Reshape into an array of size event eventDurationSamples,
  % so that each segment to be FFTed occupies one column.
  tfmap{channelNumber}(:,:) = reshape (data{channelNumber}((rejectedStart+1):(end-rejectedEnd)), eventDurationSamples,[]);

  % Transform into the frequency domain
  tfmap{channelNumber}(:,:) = fft(tfmap{channelNumber}(:,:));
end

% Get column number corresponding to the event time
newEventTime = (eventTime*sampleFrequency)-rejectedStart;
timeSlice = floor(newEventTime/eventDurationSamples)+1;

% Get row number corresponding to the event frequency
frequencyResolution = sampleFrequency/eventDurationSamples;
binCenterFrequency = [frequencyResolution:frequencyResolution:(sampleFrequency/2)].';
% Determine the closest frequency bin to our frequency
[frequencyRemaining, frequencySlice] = min(abs(eventFrequency - binCenterFrequency));

return
